---
title: "NBSS"
author: "Erin Anderson"
date: "2025-11-02"
output: html_document
---

#NBSS
#This step is using the same biovolume calculations as before except I am not aggregating by date and instead am leaving obj. biovolumes 
```{r making the biovolume df for the NBSS, include=TRUE}
library(dplyr)
library(data.table)
library(ggplot2)

# Instead of aggregating, keep the grouped data and calculate biovol_conc per row:
biovolume_nbss <- Biovolume_df %>%
  filter(!object_annotation_category %in% c("badfocus<other"), 
    !object_annotation_category %in% c("Macroalgae"),
    !grepl("^not-living>", object_annotation_hierarchy)) %>%
  group_by(Date, Fraction, Volume, Tow, Station) %>% # acq_min_mesh, acq_max_mesh
  mutate(
    biovol_conc = if_else(
      Fraction == 1,
      Spherical_volume / (Volume / 1e6), #cm^3/m^ or mL/m^3
      (Spherical_volume * (Fraction / 2)) / (Volume / 1e6) #cm^3/m^ or mL/m^3
    )
  ) %>%
  ungroup()

setDT(biovolume_nbss)
#biovolume_nbss[, sample_id := as.character(Date)]
biovolume_nbss <- biovolume_nbss %>%
  mutate(Spherical_Volume_mm3 = Spherical_volume * 1000, 
         object_esd_mm = ((object_esd)*(0.0106))) #converting ESD from pixels to mm 
#biovolume_nbss_filtered <- biovolume_nbss %>%
  #filter(Tow == 200)
biovolume_nbss <- as.data.table(biovolume_nbss)
head(biovolume_nbss)

# Install the package if you haven't already
#install.packages("writexl")

# Load the package
library(writexl)

# Export the data frame to Excel
#write_xlsx(as.data.frame(biovolume_nbss), "biovolume_nbss.xlsx")
```
```{r this is code copied from https://rdrr.io/github/clatrellu/Ecotaxa_R/src/R/nbss.R, include=TRUE}
#install.packages("data.table")
library(data.table)

#' NBSS : Normalized Biovolume Size Spectra calculation for a given sample, 
#' calculate several NBSS spectra to compare samples
#'
#' @param objects A data table containing objects in rows-not necessarily from the same sample- and details about the objects in the columns. 
#' @param samples A data table containing samples in rows and details about 
#' the latter in columns.
#' @param sample a string containing the name of the sample for which to calculate the NBSS
#' @return a data table containing two columns, the first with the size spectra, 
#' given in mm^3, the second is the NBSS for each interval of size.
#' @note The variables used are called biovolumes but to simplify we actually use 
#' volumes. Since biovolumes are the volumes normalized by the same total volume 
#' for all objects in a sample, the result is the same, except that size spectra 
#' are given in mm^3 instead of mm^3/m^3


#biovolume_nbss IS A DF WITH COLUMNS: Date, Fraction (Splitting), Volume (m^3), Spherical Volume (m^3), Tow, Station, object_id (individual vignette with detritus filtered out), biovol_conc (concentrated biovolume from ESD and filtered volume in mm^3/m^3), object_esd in microns, sample_id (shown as a date), Spherical_Volume_mm3 (converted from m^3), and acq_min and max mesh (microns)

NBSS <- function(biovolume_nbss, N = TRUE) {
  
  #if (nrow(biovolume_nbss) < 1000) {
    #warning("Warning: this sample contains less than 1000 objects; the NBSS plot might not be #representative.")
  #}
  
  # Calculate lower bound volume (Bvmin) from minimum ESD (µm to mm^3)
  #min_esd <- min(biovolume_nbss$object_esd_mm, na.rm = TRUE) #this is in mm now
  #min_radius_mm <- (min_esd_mm) / 2
  #Bvmin <- (4/3) * pi * (min_radius_mm)^3
  Bvmin <- min(biovolume_nbss$Spherical_Volume_mm3)
  # Calculate upper bound volume (top) from maximum ESD (µm to mm^3)
  #max_esd <- max(biovolume_nbss$object_esd, na.rm = TRUE) #this is also in mm now
  #max_radius_mm <- (max_esd) / 2
  #top <- (4/3) * pi * (max_radius_mm)^3
  top <- max(biovolume_nbss$Spherical_Volume_mm3)
  # Create volume intervals increasing by factor 2^(0.25) until top is reached
  intervals <- Bvmin
  current_volume <- Bvmin
  while (current_volume < top) {
    current_volume <- current_volume * 2^(0.25)
    intervals <- c(intervals, current_volume)
  }
  
  # Initialize vectors for results
  x <- numeric()
  y <- numeric()
  
  # Loop through intervals to calculate NBSS values
  for (i in 1:(length(intervals) - 1)) {
    a <- intervals[i]
    b <- intervals[i + 1]
    Bvtot <- b - a
    
    # Sum biovol_conc where Volume (converted from m^3 to mm^3) falls within [a, b)
    add_ <- biovolume_nbss[(Spherical_Volume_mm3 > a) & (Spherical_Volume_mm3 <= b), sum(biovol_conc, na.rm=TRUE)] #mL/m^3 summing all biovol_conc within rows of the correct size bin

    
    if (N) {
      add_ <- add_ / Bvtot  # Normalize by interval volume mL/m^3/mm^3
    }
    
    y <- c(y, add_)
    x <- c(x, b)
  }
  
  nbss.plot <- data.table(Spectra = x, NBSS = y) #Creating "Spectra" this is dumb change the name
  
  # Remove intervals with zero NBSS and log-transform NBSS
  nbss.plot <- nbss.plot[NBSS > 0]
  nbss.plot[, NBSS := log10(NBSS)] #log(mL/m^3/mm^3) NBSS and Spectra = log(mm^3)
  
  return(nbss.plot)
}

#' Plotting of the NBSS - Normalized Biovolume Size Spectra - of a given sample
#' @import ggplot2
#' @param objects A data table containing objects as rows and details on these objects in the 
#' columns. This argument will be passed in the NBSS function
#' @param samples A data table containing samples in rows and details about 
#' the latter in columns.
#' @param sample_name A string containing the name of the sample from which to extract objects 
#' and do an NBSS analysis.
#' @param ESD If ESD is true, by default, the x axis is expressed as ESD (Eqivalent spherical 
#' diameter for a given volume) in [µm]. Otherwise, volumes will be on the x-axis in [mm^3]
#' @return an object of the type ggplot which can then be plotted.
#' 
#' @examples 
#' p <- NBSS.plot(objects=objects,samples=samples,sample_name=sample_id,ESD=TRUE)
#' p 
#' @export NBSS.plot
NBSS.plot <- function(biovolume_nbss,ESD=TRUE){
  
  #sample_name <- biovolume_nbss[,unique(sample_id)] #Counting and calling the unique samples by name
  data <- NBSS(biovolume_nbss,N=TRUE) #setting normalized NBSS function as dataset "data" 
  
  #convert back to ESD :
  
  data[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)] #inverse of the spectra calculation back to ESD in micrometers
  
  min_mesh <- min(data$Spectra) * 1.5 #this takes the minimum value and multiplies it by 150% to account for copepods turning on their axis and slipping through the mesh netting. Currently it will scale with net size. Right now it does a good job of removing the curve and producing a relatively straight line.
  max_mesh <- max(data$Spectra) #using the maximum value within the dataset for the end of the graph
  p <- ggplot(data, aes(x = Spectra, y = NBSS))+ #This is plotting all of the points together across all size ranges. I think the next step is manually separate them so I have 2 plots. One for 200 and 1 for 700.
  geom_point() +
  scale_x_log10(limits = c(min_mesh, max_mesh)) +
  labs(
    x = "Equivalent Spherical Diameter [µm]", #correct units
    y = "NBSS log(mL/m^3/mm^3", #"NBSS [mm³/mm³/m³]" original but i think that is wrong
    title = "NBSS across samples"
  )
  
  return(p)
}
all_samples <- NBSS.plot(biovolume_nbss, ESD = TRUE)
print(all_samples)
```  

```{r NBSS by tow and by season}
meso_nbss <- biovolume_nbss %>% filter(Tow == "200")
data1 <- NBSS(meso_nbss,N=TRUE) #setting normalized NBSS function as dataset "data" 
  #data1[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)] #back to ESD

  min_mesh1 <- min(data1$Spectra)
  max_mesh1 <- max(data1$Spectra)
  
  meso_straight_esd <- data1
 meso_straight_esd <- meso_straight_esd[meso_straight_esd$Spectra>1e-01,] #selecting only the straight line
  meso_straight_esd <- meso_straight_esd[meso_straight_esd$Spectra<1e+01,]
  meso_plot_esd <- ggplot(meso_straight_esd, aes(x = Spectra, y = NBSS))+ 
  geom_point(data = data1, aes(x = Spectra, y = NBSS), color = "black")+
    geom_point(color = "red") +
  scale_x_log10(limits = c(min_mesh1, max_mesh1)) +
  labs(
    x = "Equivalent Spherical Diameter [µm]",
    y = "NBSS log[mL/m³/mm³]",
    title = NULL
  )
  
  print(meso_plot_esd)
  
model1 <- lm(NBSS ~ log10(Spectra), data = meso_straight_esd)
summary(model1)



#ggsave("NBSS_meso.png", plot = meso_plot, dpi = 300)
#browseURL("NBSS_meso.png")
#rm(model1)
#rm(meso_plot)
#rm(meso_nbss)
```



```{r NBSS by tow and by season}

# Create equation text (formatted)
macro_nbss <- biovolume_nbss %>% filter(Tow == "700")
data2 <- NBSS(macro_nbss,N=TRUE) #setting normalized NBSS function as dataset "data" 
  data2[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)] #ESD

  min_mesh2 <- min(data2$Spectra) #ESD
  max_mesh2 <- max(data2$Spectra) #ESD
  macro_straight_esd <- data2
  macro_straight_esd <- macro_straight_esd[macro_straight_esd$Spectra>1050,] #selecting only the straight line
  macro_straight_esd <- macro_straight_esd[macro_straight_esd$Spectra<10000,]
  macro_plot_esd <- ggplot(macro_straight_esd, aes(x = Spectra, y = NBSS))+ 
  geom_point(data = data2, aes(x = Spectra, y = NBSS), color = "black")+
    geom_point(color = "red") +
  scale_x_log10(limits = c(min_mesh2, max_mesh2)) +
  labs(
    x = "Equivalent Spherical Diameter [µm]",
    y = "NBSS log[mL/m³/mm³]",
    title = NULL
  )
  
print(macro_plot_esd)

model2 <- lm(NBSS ~ log10(Spectra), data = macro_straight_esd)
summary(model2)

ggsave("macro_nbss.png", plot = macro_plot_esd, dpi = 300) #, width = 14, height = 12)
browseURL("macro_nbss.png")
```
#Monthly NBSS
```{r Monthly NBSS meso}
#install.packages("purrr")
library(dplyr)
library(purrr)
library(ggplot2)

sample_nbss <- biovolume_nbss %>% filter(Tow == "200", Date == "2025-01-13")
data3 <- NBSS(meso_nbss,N=TRUE) #setting normalized NBSS function as dataset "data" 
  #data1[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)] #back to ESD

  min_mesh3 <- min(data3$Spectra)
  max_mesh3 <- max(data3$Spectra)
  
  sample_straight_esd <- data3
 sample_straight_esd <- sample_straight_esd[sample_straight_esd$Spectra>1e-01,] #selecting only the straight line
  sample_straight_esd <- sample_straight_esd[sample_straight_esd$Spectra<1e+01,]
  sample_plot_esd <- ggplot(sample_straight_esd, aes(x = Spectra, y = NBSS))+ 
  geom_point(data = data3, aes(x = Spectra, y = NBSS), color = "black")+
    geom_point(color = "red") +
  scale_x_log10(limits = c(min_mesh3, max_mesh3)) +
  labs(
    x = "Equivalent Spherical Diameter [µm]",
    y = "NBSS log[mL/m³/mm³]",
    title = NULL
  )
  
  print(sample_plot_esd)
```
```{r, NBSS per sample}
library(dplyr)
library(ggplot2)

# Get all unique dates
dates <- unique(biovolume_nbss$Date)

# Create a list to store plots
plots <- list()

for (d in dates) {
  d_str <- format(as.Date(d), "%Y-%m-%d")
  samples_nbss <- biovolume_nbss %>%
    filter(Tow == "200", Date == d)
  data4 <- NBSS(samples_nbss, N = TRUE)

  min_mesh4 <- min(data4$Spectra)
  max_mesh4 <- max(data4$Spectra)
  samples_straight_esd <- data4 %>%
    filter(Spectra > 1e-01, Spectra < 1e+01)
  p <- ggplot(samples_straight_esd, aes(x = Spectra, y = NBSS)) +
    geom_point(data = data4, aes(x = Spectra, y = NBSS), color = "black") +
    geom_point(color = "red") +
    scale_x_log10(limits = c(min_mesh4, max_mesh4)) +
    labs(
      x = "Equivalent Spherical Diameter [µm]",
      y = "NBSS log[mL/m³/mm³]",
      title = paste("NBSS – Date:", d_str)
    )

  # Save plot in list
  plots[[as.character(d_str)]] <- p

  # Print to screen
  print(p)
}

```


```{r, NBSS slopes by temperature}
pca_data
```
#Make NBSS for each season and month. Fit linear regression for all curves and compare. Use slope as a funciton of different environmental variables. Check the assumptions for SD gams. Make sure all components are normally distributed, look online to see what components I need to check and email Jerome. make boundaries 150% of mesh size. Each slope will be a value. Create data table with slope as y and month as x and graph to see how it is comparing.

