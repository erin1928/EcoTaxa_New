---
title: "NBSS"
author: "Erin Anderson"
date: "2025-11-02"
output: html_document
---

#NBSS
#This step is using the same biovolume calculations as before except I am not aggregating by date and instead am leaving obj. biovolumes 
```{r making the biovolume df for the NBSS, include=FALSE}
library(dplyr)
library(data.table)
library(ggplot2)

# Instead of aggregating, keep the grouped data and calculate biovol_conc per row:
biovolume_nbss <- Biovolume_df %>%
  filter(!object_annotation_category %in% c("badfocus<other"), 
    !object_annotation_category %in% c("Macroalgae"),
    !grepl("^not-living>", object_annotation_hierarchy)) %>%
  group_by(Date, Fraction, Volume, Tow, Station, acq_min_mesh, acq_max_mesh) %>%
  mutate(
    biovol_conc = if_else(
      Fraction == 1,
      Spherical_volume / (Volume / 1e6),
      (Spherical_volume * (Fraction / 2)) / (Volume / 1e6)
    )
  ) %>%
  ungroup()

setDT(biovolume_nbss)
biovolume_nbss[, sample_id := as.character(Date)]
biovolume_nbss <- biovolume_nbss %>%
  mutate(Spherical_Volume_mm3 = Spherical_volume * 1000)
#biovolume_nbss_filtered <- biovolume_nbss %>%
  #filter(Tow == 200)
head(biovolume_nbss)

# Install the package if you haven't already
#install.packages("writexl")

# Load the package
#library(writexl)

# Export the data frame to Excel
#write_xlsx(as.data.frame(biovolume_nbss), "biovolume_nbss.xlsx")
```
```{r this is code copied from https://rdrr.io/github/clatrellu/Ecotaxa_R/src/R/nbss.R, include=FALSE}
#install.packages("data.table")
library(data.table)

#' NBSS : Normalized Biovolume Size Spectra calculation for a given sample, 
#' calculate several NBSS spectra to compare samples
#'
#' @param objects A data table containing objects in rows-not necessarily from the same sample- and details about the objects in the columns. 
#' @param samples A data table containing samples in rows and details about 
#' the latter in columns.
#' @param sample a string containing the name of the sample for which to calculate the NBSS
#' @return a data table containing two columns, the first with the size spectra, 
#' given in mm^3, the second is the NBSS for each interval of size.
#' @note The variables used are called biovolumes but to simplify we actually use 
#' volumes. Since biovolumes are the volumes normalized by the same total volume 
#' for all objects in a sample, the result is the same, except that size spectra 
#' are given in mm^3 instead of mm^3/m^3


#biovolume_nbss IS A DF WITH COLUMNS: Date, Fraction (Splitting), Volume (m^3), Spherical Volume (m^3), Tow, Station, object_id (individual vignette with detritus filtered out), biovol_conc (concentrated biovolume from ESD and filtered volume in individuals/m^3), object_esd in microns, sample_id (shown as a date), Spherical_Volume_mm3 (converted from m^3), and acq_min and max mesh (microns)

NBSS <- function(biovolume_nbss, N = TRUE) {
  
  #if (nrow(biovolume_nbss) < 1000) {
    #warning("Warning: this sample contains less than 1000 objects; the NBSS plot might not be #representative.")
  #}
  
  # Calculate lower bound volume (Bvmin) from minimum ESD (µm to mm^3)
  min_esd <- min(biovolume_nbss$object_esd, na.rm = TRUE)
  min_radius_mm <- (min_esd * 1e-3) / 2
  Bvmin <- (4/3) * pi * (min_radius_mm)^3
  
  # Calculate upper bound volume (top) from maximum ESD (µm to mm^3)
  max_esd <- max(biovolume_nbss$object_esd, na.rm = TRUE)
  max_radius_mm <- (max_esd * 1e-3) / 2
  top <- (4/3) * pi * (max_radius_mm)^3
  
  # Create volume intervals increasing by factor 2^(0.25) until top is reached
  intervals <- Bvmin
  current_volume <- Bvmin
  while (current_volume < top) {
    current_volume <- current_volume * 2^(0.25)
    intervals <- c(intervals, current_volume)
  }
  
  # Initialize vectors for results
  x <- numeric()
  y <- numeric()
  
  # Loop through intervals to calculate NBSS values
  for (i in 1:(length(intervals) - 1)) {
    a <- intervals[i]
    b <- intervals[i + 1]
    Bvtot <- b - a
    
    # Sum biovol_conc where Volume (converted from m^3 to mm^3) falls within [a, b)
    add_ <- biovolume_nbss[(Spherical_Volume_mm3 > a) & (Spherical_Volume_mm3 <= b), sum(biovol_conc, na.rm=TRUE)]

    
    if (N) {
      add_ <- add_ / Bvtot  # Normalize by interval volume
    }
    
    y <- c(y, add_)
    x <- c(x, b)
  }
  
  nbss.plot <- data.table(Spectra = x, NBSS = y) #Creating "Spectra"
  
  # Remove intervals with zero NBSS and log-transform NBSS
  nbss.plot <- nbss.plot[NBSS > 0]
  nbss.plot[, NBSS := log10(NBSS)]
  
  return(nbss.plot)
}

#' Plotting of the NBSS - Normalized Biovolume Size Spectra - of a given sample
#' @import ggplot2
#' @param objects A data table containing objects as rows and details on these objects in the 
#' columns. This argument will be passed in the NBSS function
#' @param samples A data table containing samples in rows and details about 
#' the latter in columns.
#' @param sample_name A string containing the name of the sample from which to extract objects 
#' and do an NBSS analysis.
#' @param ESD If ESD is true, by default, the x axis is expressed as ESD (Eqivalent spherical 
#' diameter for a given volume) in [µm]. Otherwise, volumes will be on the x-axis in [mm^3]
#' @return an object of the type ggplot which can then be plotted.
#' 
#' @examples 
#' p <- NBSS.plot(objects=objects,samples=samples,sample_name=sample_id,ESD=TRUE)
#' p 
#' @export NBSS.plot

NBSS.plot <- function(biovolume_nbss,ESD=TRUE){
  
  sample_name <- biovolume_nbss[,unique(sample_id)] #Counting and calling the unique samples by name
  data <- NBSS(biovolume_nbss,N=TRUE) #setting normalized NBSS function as dataset "data"
  
  #convert back to ESD :
  
  data[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)] #I don't follow what's happening here, why would we convert ESD just to convert it back? Is this to match units for the final graph?
  
  min_mesh <- unique(biovolume_nbss$acq_min_mesh) #can we manually bin this? 200-700 and 700+ for each tow type?
  max_mesh <- unique(biovolume_nbss$acq_max_mesh) #somewhere this is what is getting messed up. Are the above lines supposed to combine into the original data frame and if so why is it not working? I think when I am printing it is these new columns that are not coming through effectively.
  
  p <- ggplot(data,aes(x=Spectra,y=NBSS)) + 
    geom_point()  + scale_x_log10(limits=c(min_mesh,max_mesh))+
    labs(x="Equivalent Spherical Diameter [µm]",y="NBSS [mm^3/mm^3/m^3]",title = paste("NBSS:",sample_name)) #is this making one NBSS per sample? How do I combine multiple together?
  
  return(p)
}
p <- NBSS.plot(biovolume_nbss, ESD = TRUE)
print(p)
```  

```{r this is code copied from https://rdrr.io/github/clatrellu/Ecotaxa_R/src/R/nbss.R, include=FALSE}
BSS.plot <- function(biovolume_nbss,ESD=TRUE){
  
  sample_name <- biovolume_nbss[,unique(object_id)]
  data <- NBSS(biovolume_nbss,N=FALSE)
  
  #convert back to ESD :
  
  data[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)]
  
  min_esd <- unique(bin_min = biovolume_nbss %>% min(biovolume_nbss$object_esd))
  max_esd <- unique(bin_max = biovolume_nbss %>% max(biovolume_nbss$object_esd))
  
  p <- ggplot(data,aes(x=Spectra,y=NBSS)) + 
    geom_point()  + scale_x_log10(limits=c(min_esd,max_esd))+
    labs(x="Equivalent Spherical Diameter [µm]",y="BSS [mm^3/m^3]",title = paste("BSS:",sample_name))
  
  return(p)
}

#this is for one sample at a time
NBSS.plot <- function(biovolume_nbss,ESD=TRUE){
  
  sample_name <- unique(biovolume_nbss$object_id)
  nbss_data <- NBSS(biovolume_nbss,N=TRUE)
  
  #convert back to ESD :
  
  # Convert Spectra from m^3 to mm^3 first
  nbss_data[, Spectra := Spectra * 1e9]  

# Then convert volume (mm^3) to ESD (µm)
  nbss_data[, Spectra := 2 * 1e3 * (Spectra * 3 / (4 * pi))^(1/3)]
  
  min_esd <- min(biovolume_nbss$object_esd, na.rm = TRUE)
  max_esd <- max(biovolume_nbss$object_esd, na.rm = TRUE)
  
  p <- ggplot(nbss_data,aes(x=Spectra,y=NBSS)) + 
    geom_point()  + scale_x_log10(limits=c(min_esd,max_esd))+
    labs(x="Equivalent Spherical Diameter [µm]",y="NBSS [mm^3/mm^3/m^3]",title = paste("NBSS:",sample_name))
  
  return(p)
}

```

