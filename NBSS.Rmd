---
title: "NBSS"
author: "Erin Anderson"
date: "2025-11-02"
output: html_document
---

#NBSS
#This step is using the same biovolume calculations as before except I am not aggregating by date and instead am leaving obj. biovolumes 
```{r making the biovolume df for the NBSS, include=TRUE}
library(dplyr)
library(data.table)
library(ggplot2)

# Instead of aggregating, keep the grouped data and calculate biovol_conc per row:
biovolume_nbss <- Biovolume_df %>%
  filter(!object_annotation_category %in% c("badfocus<other"), 
    !object_annotation_category %in% c("Macroalgae"),
    !grepl("^not-living>", object_annotation_hierarchy)) %>%
  group_by(Date, Fraction, Volume, Tow, Station) %>% # acq_min_mesh, acq_max_mesh
  mutate(
    biovol_conc = if_else(
      Fraction == 1,
      Spherical_volume / (Volume / 1e6), #cm^3/m^ or mL/m^3
      (Spherical_volume * (Fraction / 2)) / (Volume / 1e6) #cm^3/m^ or mL/m^3
    )
  ) %>%
  ungroup()

setDT(biovolume_nbss)
#biovolume_nbss[, sample_id := as.character(Date)]
biovolume_nbss <- biovolume_nbss %>%
  mutate(Spherical_Volume_mm3 = Spherical_volume * 1000, 
         object_esd_mm = ((object_esd)*(0.0106))) #converting ESD from pixels to mm 
#biovolume_nbss_filtered <- biovolume_nbss %>%
  #filter(Tow == 200)
biovolume_nbss <- as.data.table(biovolume_nbss)
head(biovolume_nbss)

# Install the package if you haven't already
#install.packages("writexl")

# Load the package
#library(writexl)

# Export the data frame to Excel
#write_xlsx(as.data.frame(biovolume_nbss), "biovolume_nbss.xlsx")
```
```{r this is code copied from https://rdrr.io/github/clatrellu/Ecotaxa_R/src/R/nbss.R, include=TRUE}
#install.packages("data.table")
library(data.table)

#' NBSS : Normalized Biovolume Size Spectra calculation for a given sample, 
#' calculate several NBSS spectra to compare samples
#'
#' @param objects A data table containing objects in rows-not necessarily from the same sample- and details about the objects in the columns. 
#' @param samples A data table containing samples in rows and details about 
#' the latter in columns.
#' @param sample a string containing the name of the sample for which to calculate the NBSS
#' @return a data table containing two columns, the first with the size spectra, 
#' given in mm^3, the second is the NBSS for each interval of size.
#' @note The variables used are called biovolumes but to simplify we actually use 
#' volumes. Since biovolumes are the volumes normalized by the same total volume 
#' for all objects in a sample, the result is the same, except that size spectra 
#' are given in mm^3 instead of mm^3/m^3


#biovolume_nbss IS A DF WITH COLUMNS: Date, Fraction (Splitting), Volume (m^3), Spherical Volume (m^3), Tow, Station, object_id (individual vignette with detritus filtered out), biovol_conc (concentrated biovolume from ESD and filtered volume in mm^3/m^3), object_esd in microns, sample_id (shown as a date), Spherical_Volume_mm3 (converted from m^3), and acq_min and max mesh (microns)

NBSS <- function(biovolume_nbss, N = TRUE) {
  
  #if (nrow(biovolume_nbss) < 1000) {
    #warning("Warning: this sample contains less than 1000 objects; the NBSS plot might not be #representative.")
  #}
  
  # Calculate lower bound volume (Bvmin) from minimum ESD (µm to mm^3)
  #min_esd <- min(biovolume_nbss$object_esd_mm, na.rm = TRUE) #this is in mm now
  #min_radius_mm <- (min_esd_mm) / 2
  #Bvmin <- (4/3) * pi * (min_radius_mm)^3
  Bvmin <- min(biovolume_nbss$Spherical_Volume_mm3)
  # Calculate upper bound volume (top) from maximum ESD (µm to mm^3)
  #max_esd <- max(biovolume_nbss$object_esd, na.rm = TRUE) #this is also in mm now
  #max_radius_mm <- (max_esd) / 2
  #top <- (4/3) * pi * (max_radius_mm)^3
  top <- max(biovolume_nbss$Spherical_Volume_mm3)
  # Create volume intervals increasing by factor 2^(0.25) until top is reached
  intervals <- Bvmin
  current_volume <- Bvmin
  while (current_volume < top) {
    current_volume <- current_volume * 2^(0.25)
    intervals <- c(intervals, current_volume)
  }
  
  # Initialize vectors for results
  x <- numeric()
  y <- numeric()
  
  # Loop through intervals to calculate NBSS values
  for (i in 1:(length(intervals) - 1)) {
    a <- intervals[i]
    b <- intervals[i + 1]
    Bvtot <- b - a
    
    # Sum biovol_conc where Volume (converted from m^3 to mm^3) falls within [a, b)
    add_ <- biovolume_nbss[(Spherical_Volume_mm3 > a) & (Spherical_Volume_mm3 <= b), sum(biovol_conc, na.rm=TRUE)] #mL/m^3 summing all biovol_conc within rows of the correct size bin

    
    if (N) {
      add_ <- add_ / Bvtot  # Normalize by interval volume mL/m^3/mm^3
    }
    
    y <- c(y, add_)
    x <- c(x, b)
  }
  
  nbss.plot <- data.table(Spectra = x, NBSS = y) #Creating "Spectra" this is dumb change the name
  
  # Remove intervals with zero NBSS and log-transform NBSS
  nbss.plot <- nbss.plot[NBSS > 0]
  nbss.plot[, NBSS := log10(NBSS)] #log(mL/m^3/mm^3) NBSS and Spectra = log(mm^3)
  
  return(nbss.plot)
}

#' Plotting of the NBSS - Normalized Biovolume Size Spectra - of a given sample
#' @import ggplot2
#' @param objects A data table containing objects as rows and details on these objects in the 
#' columns. This argument will be passed in the NBSS function
#' @param samples A data table containing samples in rows and details about 
#' the latter in columns.
#' @param sample_name A string containing the name of the sample from which to extract objects 
#' and do an NBSS analysis.
#' @param ESD If ESD is true, by default, the x axis is expressed as ESD (Eqivalent spherical 
#' diameter for a given volume) in [µm]. Otherwise, volumes will be on the x-axis in [mm^3]
#' @return an object of the type ggplot which can then be plotted.
#' 
#' @examples 
#' p <- NBSS.plot(objects=objects,samples=samples,sample_name=sample_id,ESD=TRUE)
#' p 
#' @export NBSS.plot
NBSS.plot <- function(biovolume_nbss,ESD=TRUE){
  
  #sample_name <- biovolume_nbss[,unique(sample_id)] #Counting and calling the unique samples by name
  data <- NBSS(biovolume_nbss,N=TRUE) #setting normalized NBSS function as dataset "data" 
  
  #convert back to ESD :
  
  data[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)] #inverse of the spectra calculation back to ESD in micrometers
  
  min_mesh <- min(data$Spectra) * 1.5 #this takes the minimum value and multiplies it by 150% to account for copepods turning on their axis and slipping through the mesh netting. Currently it will scale with net size. Right now it does a good job of removing the curve and producing a relatively straight line.
  max_mesh <- max(data$Spectra) #using the maximum value within the dataset for the end of the graph
  p <- ggplot(data, aes(x = Spectra, y = NBSS))+ #This is plotting all of the points together across all size ranges. I think the next step is manually separate them so I have 2 plots. One for 200 and 1 for 700.
  geom_point() +
  scale_x_log10(limits = c(min_mesh, max_mesh)) +
  labs(
    x = "Equivalent Spherical Diameter [µm]", #correct units
    y = "NBSS log(mL/m^3/mm^3", #"NBSS [mm³/mm³/m³]" original but i think that is wrong
    title = "NBSS across samples"
  )
  
  return(p)
}
all_samples <- NBSS.plot(biovolume_nbss, ESD = TRUE)
print(all_samples)
```  

```{r NBSS by tow and by season}
#meso_nbss <- biovolume_nbss %>% filter(Tow == "200")

#just_meso <- NBSS.plot(meso_nbss, ESD = TRUE)
#print(just_meso)
#start is 302.6836 microns

meso_nbss <- biovolume_nbss %>% filter(Tow == "200")
data1 <- NBSS(meso_nbss,N=TRUE) #setting normalized NBSS function as dataset "data" 
  data1[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)]

  min_mesh1 <- min(data1$Spectra)*1.5 #- not working as intended, multiplied 700*1.5 and added that as minimum
  # min(large_nbss$object_esd) #micro m -- JP not really of mesh but of particles

  max_mesh1 <- max(data1$Spectra)
  meso_plot <- ggplot(data1, aes(x = Spectra, y = NBSS))+ 
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  annotate(
    "text",
    x = 8000, 
    y = 3,
    label = eq_label,
    hjust = 0,
    vjust = 1,
    size = 4) +
  scale_x_log10(limits = c(min_mesh1, max_mesh1)) +
  labs(
    x = "Equivalent Spherical Diameter [µm]",
    y = "NBSS log[mL/m³/mm³]",
    title = NULL
  )
  
  print(meso_plot)
  
# Fitting a linear regression for the subsetted data I plotted, NOT the full range of values in data1
lm_data <- data1 %>%
  filter(Spectra >= min_mesh1, Spectra <= max_mesh1)
  
model1 <- lm(NBSS ~ Spectra, data = lm_data)
summary(model1)

# Extract coefficients
intercept <- coef(model1)[1]
slope <- coef(model1)[2]

# Create equation text (formatted)
eq_label <- paste0(
  "y = ", round(slope, 6), "x + ", round(intercept, 3)
)


```

```{r NBSS by tow and by season}
#macro_nbss <- biovolume_nbss %>% filter(Tow == "700")

#just_macro <- NBSS.plot(macro_nbss, ESD = TRUE)
#print(just_macro)

# Create equation text (formatted)
macro_nbss <- biovolume_nbss %>% filter(Tow == "700")
data2 <- NBSS(macro_nbss,N=TRUE) #setting normalized NBSS function as dataset "data" 
  data2[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)]

  min_mesh2 <- min(1050) #data2$Spectra)*1.5 - not working as intended, multiplied 700*1.5 and added that as minimum
  # min(large_nbss$object_esd) #micro m -- JP not really of mesh but of particles

  max_mesh2 <- max(data2$Spectra)
  
  data2_filtered <- data2 %>% 
    filter(Spectra >= 1050)
  model2 <- lm(NBSS ~ Spectra, data = data2_filtered)
  summary(model2)
# Extract coefficients
intercept1 <- coef(model2)[1]
slope1 <- coef(model2)[2]
eq_label1 <- paste0(
  "y = ", round(slope1, 6), "x + ", round(intercept1, 3)
)
  
q <- ggplot(data2, aes(x = Spectra, y = NBSS))+ 
  geom_point() +
    geom_smooth(method = "lm", se = FALSE, color = "red") +
  annotate(
    "text",
    x = 3000, 
    y = 0.75,
    label = eq_label1,
    hjust = 0,
    vjust = 1,
    size = 4) +
  scale_x_log10(limits = c(min_mesh2, max_mesh2)) +
  labs(
    x = "Equivalent Spherical Diameter [µm]",
    y = "NBSS log[mL/m³/mm³]",
    title = NULL
  )
  
  print(q) 
  
plot(model2, which = 3)
```
#Monthly NBSS
```{r Monthly NBSS meso}
#max_mesh3 <- max(data3$Spectra, na.rm=TRUE)


#jan_nbss <- ggplot(data3, aes(x = Spectra, y = NBSS)) +geom_point() +scale_x_log10(limits = c(min_mesh3, max_mesh3)) +labs(x = "Equivalent Spherical Diameter [µm]",y = "NBSS log[mL/m³/mm³]",title = paste("NBSS for Month", m))
#print(jan_nbss) 

library(dplyr)
library(ggplot2)
library(lubridate)
library(data.table)


monthly_nbss <- biovolume_nbss %>%
  filter(Tow == "200") %>%
  mutate(Month = month(Date),
         Year  = year(Date))
data3 <- NBSS(monthly_nbss, N = TRUE)
data3[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)]
min_mesh3 <- 350                          # fixed lower limit
for (yy in sort(unique(monthly_nbss$Year))) {
  
  yearly_data <- monthly_nbss %>% filter(Year == yy)
  
  for (mm in sort(unique(yearly_data$Month))) {
    
    # Filter this year + month
    month_data <- yearly_data %>% filter(Month == mm)
    
    # Run NBSS for this subset
    data3 <- NBSS(month_data, N = TRUE)
    data3 <- as.data.frame(data3)     # avoid data.table side-effects
    
    # Transform Spectra
    data3$Spectra <- 2 * 10^3 * (data3$Spectra * 3 / (4 * pi))^(1/3)
    
    # Determine maximum ESD for this month & year
    max_mesh3 <- max(data3$Spectra, na.rm = TRUE)

    # Build the plot
    p <- ggplot(data3, aes(x = Spectra, y = NBSS)) +
      geom_point() +
      scale_x_log10(limits = c(min_mesh3, max_mesh3)) +
      labs(
        x = "Equivalent Spherical Diameter [µm]",
        y = "NBSS log[mL/m³/mm³]",
        title = paste("NBSS for", yy, "Month", mm)
      )
    
    # Print the plot
    print(p)
  }
}
```

#Make NBSS for each season and month. Fit linear regression for all curves and compare. Use slope as a funciton of different environmental variables. Check the assumptions for SD gams. Make sure all components are normally distributed, look online to see what components I need to check and email Jerome. make boundaries 150% of mesh size. Each slope will be a value. Create data table with slope as y and month as x and graph to see how it is comparing.

