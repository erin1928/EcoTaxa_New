---
title: "Linear Regressions"
author: "Erin Anderson"
date: "2025-11-23"
output: html_document
---

#NBSS
#This step is using the same biovolume calculations as before except I am not aggregating by date and instead am leaving obj. biovolumes 
```{r making the biovolume df for the NBSS, include=TRUE}
library(dplyr)
library(data.table)
library(ggplot2)
```

```{r this is code copied from https://rdrr.io/github/clatrellu/Ecotaxa_R/src/R/nbss.R, include=TRUE}
library(data.table)

NBSS <- function(biovolume_nbss, N = TRUE) {
  Bvmin <- min(biovolume_nbss$Spherical_Volume_mm3) #mm^3
  # Calculate upper bound volume (top) from maximum ESD (µm to mm^3)
  top <- max(biovolume_nbss$Spherical_Volume_mm3) #mm^3
  # Create volume intervals increasing by factor 2^(0.25) until top is reached
  intervals <- Bvmin #mm^3
  current_volume <- Bvmin
  while (current_volume < top) {
    current_volume <- current_volume * 2^(0.25)
    intervals <- c(intervals, current_volume) #mm^3
  }
  
  # Initialize vectors for results
  x <- numeric()
  y <- numeric()
  
  # Loop through intervals to calculate NBSS values
  for (i in 1:(length(intervals) - 1)) {
    a <- intervals[i]
    b <- intervals[i + 1]
    Bvtot <- b - a #mm^3
    
    # Sum biovol_conc where Volume (converted from m^3 to mm^3) falls within [a, b)
    add_ <- biovolume_nbss[(Spherical_Volume_mm3 > a) & (Spherical_Volume_mm3 <= b), sum(biovol_conc, na.rm=TRUE)] #mL/m^3 summing all biovol_conc within rows of the correct size bin

    
    if (N) {
      add_ <- add_ / Bvtot  # Normalize by interval volume mL/m^3/mm^3
    }
    
    y <- c(y, add_)
    x <- c(x, b)
  }
  
  nbss.plot <- data.table(Spectra = x, NBSS = y) #Creating "Spectra" 
  # Remove intervals with zero NBSS and log-transform NBSS
  nbss.plot <- nbss.plot[NBSS > 0]
  nbss.plot[, NBSS := log10(NBSS)] #log(mL/m^3/mm^3) NBSS and Spectra = mm^3
  
  return(nbss.plot)
}

NBSS.plot <- function(biovolume_nbss,ESD=TRUE){
  data <- NBSS(biovolume_nbss,N=TRUE) #setting normalized NBSS function as dataset "data" 
  #convert back to ESD :
  data[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)] #inverse of the spectra calculation back to ESD in micrometers
  
  min_mesh <- min(data$Spectra) * 1.5 #this takes the minimum value and multiplies it by 150% to account for copepods turning on their axis and slipping through the mesh netting. Currently it will scale with net size. Right now it does a good job of removing the curve and producing a relatively straight line.
  max_mesh <- max(data$Spectra) #using the maximum value within the dataset for the end of the graph
  p <- ggplot(data, aes(x = Spectra, y = NBSS))+ #This is plotting all of the points together across all size ranges. I think the next step is manually separate them so I have 2 plots. One for 200 and 1 for 700.
  geom_point() +
  scale_x_log10(limits = c(min_mesh, max_mesh)) +
  labs(
    x = "Equivalent Spherical Diameter [µm]", #correct units
    y = "NBSS log(mL/m^3/mm^3)",
    title = "NBSS across samples"
  )
  
  return(p)
}
all_samples <- NBSS.plot(biovolume_nbss, ESD = TRUE)
print(all_samples)
``` 

```{r NBSS by tow and by season}
meso_nbss_mm_3 <- biovolume_nbss %>% filter(Tow == "200")
data1 <- NBSS(meso_nbss_mm_3,N=TRUE) #NBSS is in log form but Spectra is in mm^3

  min_mesh1 <- 4/3*pi*(min(data1$Spectra)/2)^3 #mm^3
  max_mesh1 <- 4/3*pi*(max(data1$Spectra)/2)^3 #mm^3
  
  meso_straight_mm_3 <- data1
  meso_straight_mm_3$Spectra <-  4/3*pi*(meso_straight_mm_3$Spectra/2)^3 #mm3
  meso_straight_mm_3 <- meso_straight_mm_3[meso_straight_mm_3$Spectra>10^-3,] #selecting only the straight line
  meso_straight_mm_3 <- meso_straight_mm_3[meso_straight_mm_3$Spectra<10^3,]
  meso_plot_mm_3 <- ggplot(meso_straight_mm_3, aes(x = Spectra, y = NBSS))+ 
  geom_point(data = data1, aes(x = 4/3*pi*(Spectra/2)^3, y = NBSS), color = "black")+
    geom_point(color = "red") +
  scale_x_log10(limits = c(min_mesh1, max_mesh1)) +
  labs(
    x = "Equivalent Spherical Diameter [µm]",
    y = "NBSS log[mL/m³/mm³]",
    title = NULL
  )
  
  print(meso_plot_mm_3)
  
model1_mm_3 <- lm(NBSS ~ log10(Spectra), data = meso_straight_mm_3)
summary(model1_mm_3)


meso_plot_mm_3 + geom_abline(intercept = model1$coefficients[1], slope = model1$coefficients[2], color = "red")
#ggsave("NBSS_meso.png", plot = meso_plot, dpi = 300)
#browseURL("NBSS_meso.png")
#rm(model1)
#rm(meso_plot)
#rm(meso_nbss)
```
```{r, NBSS all samples using volume instead of ESD}
nbss_data <- NBSS(biovolume_nbss,N=TRUE) 

  min_mesh <- 4/3*pi*(min(nbss_data$Spectra)/2)^3 
  
  max_mesh <- 4/3*pi*(max(nbss_data$Spectra)/2)^3 

  NBSS_straight <- nbss_data
  NBSS_straight$Spectra <-  4/3*pi*(NBSS_straight$Spectra/2)^3 #mm3
  NBSS_straight <- NBSS_straight[NBSS_straight$Spectra>10^-3,] #selecting only the straight line
  NBSS_straight <- NBSS_straight[NBSS_straight$Spectra<10^4,]
  
 Q <-  ggplot(NBSS_straight, aes(x = Spectra, y = NBSS))+
     geom_point(data = nbss_data, aes(x = 4/3*pi*(Spectra/2)^3, y = NBSS), color = "black")+
    geom_point(color = "red") +
  scale_x_log10(limits = c(min_mesh, max_mesh)) +
     labs(
         x = "Volume [mm3]",
         y = "NBSS log10([mL/mm³/m³])",
         title = "NBSS across samples"
     )


m1 <- lm(NBSS ~ log10(Spectra), data = NBSS_straight)
summary(m1)

Q + geom_abline(intercept = m1$coefficients[1], slope = m1$coefficients[2], color = "red")

#rm(nbss_data)
#rm(Q)
#rm(m1)
#rm(NBSS_straight)
print(NBSS_straight)
```
```{r NBSS by tow and by season}
#macro_nbss <- biovolume_nbss %>% filter(Tow == "700")

#just_macro <- NBSS.plot(macro_nbss, ESD = TRUE)
#print(just_macro)

# Create equation text (formatted)
macro_nbss <- biovolume_nbss %>% filter(Tow == "700")
data2 <- NBSS(macro_nbss,N=TRUE) #setting normalized NBSS function as dataset "data" 
  data2[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)]

  min_mesh2 <- min(1050) #data2$Spectra)*1.5 - not working as intended, multiplied 700*1.5 and added that as minimum
  # min(large_nbss$object_esd) #micro m -- JP not really of mesh but of particles

  max_mesh2 <- max(data2$Spectra)
  
  data2_filtered <- data2 %>% 
    filter(Spectra >= 1050)
  model2 <- lm(NBSS ~ log(Spectra), data = data2_filtered)
  summary(model2)
# Extract coefficients
intercept1 <- coef(model2)[1]
slope1 <- coef(model2)[2]
eq_label1 <- paste0(
  "y = ", round(slope1, 6), "x + ", round(intercept1, 3)
)
  
q <- ggplot(data2, aes(x = Spectra, y = NBSS))+ 
  geom_point() +
  scale_x_log10(limits = c(min_mesh2, max_mesh2)) +
  labs(
    x = "Equivalent Spherical Diameter [µm]",
    y = "NBSS log[mL/m³/mm³]",
    title = NULL
  )
  
  print(q) 
  


#geom_smooth(method = "lm", se = FALSE, color = "red") + annotate("text",x = 3000, y = 0.75,label = eq_label1,hjust = 0,vjust = 1,size = 4) +
```
#Monthly NBSS
```{r Monthly NBSS meso}
library(dplyr)
library(ggplot2)
library(lubridate)
library(data.table)


monthly_nbss <- biovolume_nbss %>%
  filter(Tow == "200") %>%
  mutate(Month = month(Date),
         Year  = year(Date))
data3 <- NBSS(monthly_nbss, N = TRUE)
data3[,Spectra:=2*10**3*(Spectra*3/(4*pi))**(1/3)]
min_mesh3 <- 350  # fixed lower limit (microns)
model_list <- list()
for (yy in sort(unique(monthly_nbss$Year))) {
  
  yearly_data <- monthly_nbss %>% filter(Year == yy)
  
  for (mm in sort(unique(yearly_data$Month))) {
    
    # Filter this year + month
    month_data <- yearly_data %>% filter(Month == mm)
    
    # Run NBSS for this subset
    data3 <- NBSS(month_data, N = TRUE)
    data3 <- as.data.frame(data3)     # avoid data.table side-effects
    
    # Transform Spectra
    data3$Spectra <- 2 * 10^3 * (data3$Spectra * 3 / (4 * pi))^(1/3) #microns
    
    # Determine maximum ESD for this month & year
    max_mesh3 <- max(data3$Spectra, na.rm = TRUE)
    monthly_straight <- data3
    monthly_straight <- monthly_straight[monthly_straight$Spectra>700,] #selecting only the straight line
  monthly_straight <- monthly_straight[monthly_straight$Spectra<3000,]
model_name <- paste0("lm_", yy, "_", mm)
    fit <- lm(NBSS ~ log10(Spectra), data = monthly_straight)

    # Save model for later use
    model_list[[model_name]] <- fit
    # Build the plot
    p <- ggplot(monthly_straight, aes(x = Spectra, y = NBSS)) +
      geom_point(data = data3, aes(Spectra, y = NBSS), color = "black")+
    geom_point(color = "red") +
      scale_x_log10(limits = c(min_mesh3, max_mesh3)) +
      labs(
        x = "Equivalent Spherical Diameter [µm]",
        y = "NBSS log[mL/m³/mm³]",
        title = paste("NBSS for", yy, "Month", mm)
      )
    
    # Print the plot
    print(p)
  }
}

model_list[["lm_2024_5"]]
model_list[["lm_2024_6"]]
model_list[["lm_2024_7"]]
model_list[["lm_2024_8"]]
model_list[["lm_2024_9"]]
model_list[["lm_2024_10"]]
model_list[["lm_2024_11"]]
model_list[["lm_2024_12"]]
model_list[["lm_2025_1"]]
model_list[["lm_2025_2"]]
model_list[["lm_2025_3"]]
model_list[["lm_2025_4"]]
model_list[["lm_2025_5"]]
model_list[["lm_2025_6"]]
model_list[["lm_2025_7"]]
model_list[["lm_2025_8"]]
model_list[["lm_2025_9"]]
library(broom)   # for tidy() summaries

# Create empty list to store results
rows <- list()

for (name in names(model_list)) {
  
  model <- model_list[[name]]
  tidy_mod <- tidy(model)
  glance_mod <- glance(model)
  
  # Extract year_month from name "lm_2024_5" → year = 2024, month = 5
  parts <- unlist(strsplit(name, "_"))
  year  <- as.numeric(parts[2])
  month <- as.numeric(parts[3])
  
  # Get slope & intercept
  intercept <- tidy_mod$estimate[ tidy_mod$term == "(Intercept)" ]
  slope     <- tidy_mod$estimate[ tidy_mod$term != "(Intercept)" ]
  
  # Add row
  rows[[name]] <- data.table(
    model_name = name,
    year = year,
    month = month,
    intercept = intercept,
    slope = slope,
    r_squared = glance_mod$r.squared,
    adj_r_squared = glance_mod$adj.r.squared,
    p_value = tidy_mod$p.value[ tidy_mod$term != "(Intercept)" ],
    n = glance_mod$nobs
  )
}

# Combine into one table
meso_slopes_table <- rbindlist(rows)
meso_slopes_table
fwrite(meso_slopes_table, "NBSS_model_summary.csv")
```

#Make NBSS for each season and month. Fit linear regression for all curves and compare. Use slope as a funciton of different environmental variables. Check the assumptions for SD gams. Make sure all components are normally distributed, look online to see what components I need to check and email Jerome. make boundaries 150% of mesh size. Each slope will be a value. Create data table with slope as y and month as x and graph to see how it is comparing.

